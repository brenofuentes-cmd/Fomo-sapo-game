<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#07110d" />
  <title>FOMO SAPO ‚Äî Swamp Tongue</title>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#07110d;
      --neonG:#39FF14;
      --neonC:#00E5FF;
      --neonP:#B100FF;
      --gold:#FFD700;
      --text:#EAF7FF;
      --stroke: rgba(255,255,255,.18);
      --radius: 26px;
    }
    *{ box-sizing:border-box; }
    html,body{
      height:100%; margin:0;
      background: radial-gradient(1000px 700px at 50% 15%, #0a2a1e 0%, var(--bg0) 55%, #020606 100%);
      color:var(--text);
      font-family: "Space Grotesk", system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
      -webkit-user-select:none; user-select:none;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none;
    }
    #wrap{
      position:fixed; inset:0;
      display:grid; place-items:center;
      padding:
        env(safe-area-inset-top)
        env(safe-area-inset-right)
        env(safe-area-inset-bottom)
        env(safe-area-inset-left);
    }
    #stage{
      position:relative;
      width:min(96vw, 560px);
      height:min(90vh, 980px);
      z-index:1;
    }
    canvas{
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      border-radius: var(--radius);
      display:block;
      background: linear-gradient(180deg, rgba(7,17,13,.2), rgba(2,6,6,.35));
      box-shadow:
        0 0 0 1px rgba(255,255,255,.10),
        0 0 55px rgba(57,255,20,.20),
        0 0 90px rgba(0,229,255,.12),
        inset 0 0 90px rgba(0,0,0,.35);
      touch-action: manipulation;
      z-index:10;
    }

    /* ===== HUD (top) ===== */
    .hud{
      position:absolute;
      left:14px; right:14px; top:14px;
      display:flex;
      gap:10px;
      justify-content:space-between;
      flex-wrap:wrap;
      pointer-events:none;
      z-index:100;
    }
    .pill{
      pointer-events:none;
      padding:10px 14px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: linear-gradient(135deg, rgba(57,255,20,.14), rgba(0,229,255,.10));
      backdrop-filter: blur(12px);
      box-shadow: 0 6px 18px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.10);
      font-family:"Orbitron", monospace;
      font-weight:800;
      letter-spacing:1px;
      font-size:11px;
      text-transform:uppercase;
      white-space:nowrap;
    }
    .pill b{
      color: var(--neonG);
      text-shadow: 0 0 14px rgba(57,255,20,.55);
    }
    .pill.warn b{ color: #FFD700; text-shadow: 0 0 14px rgba(255,215,0,.55); }
    .pill.danger b{ color: #ff4d8d; text-shadow: 0 0 14px rgba(255,77,141,.55); }

    /* Side tab handles */
    .tab-handle{
      position:absolute;
      top:110px;
      width:44px;
      height:120px;
      display:grid;
      place-items:center;
      border:1px solid var(--stroke);
      background: linear-gradient(145deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      backdrop-filter: blur(14px);
      box-shadow: 0 12px 28px rgba(0,0,0,.35);
      z-index:200;
      cursor:pointer;
      user-select:none;
    }
    .tab-handle span{
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      font-family:"Orbitron", monospace;
      font-weight:900;
      letter-spacing:2px;
      font-size:11px;
      opacity:.92;
    }
    #handleLeft{ left:-1px; border-top-right-radius:18px; border-bottom-right-radius:18px; }
    #handleRight{ right:-1px; border-top-left-radius:18px; border-bottom-left-radius:18px; }

    /* Panels */
    .panel{
      position:absolute;
      top:80px;
      bottom:18px;
      width:min(86%, 380px);
      border-radius:22px;
      border:1px solid var(--stroke);
      background: linear-gradient(145deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      backdrop-filter: blur(18px);
      box-shadow: 0 18px 46px rgba(0,0,0,.45), 0 0 60px rgba(57,255,20,.10);
      z-index:300;
      padding:16px 16px 14px;
      overflow:auto;
      display:none;
    }
    #panelLeft{ left:12px; }
    #panelRight{ right:12px; }

    .panel h3{
      margin:4px 0 10px;
      font-family:"Orbitron", monospace;
      font-weight:900;
      letter-spacing:1.5px;
      font-size:14px;
      text-transform:uppercase;
    }
    .panel .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      margin-bottom:10px;
    }
    .muted{ opacity:.78; font-size:13px; line-height:1.45; }
    .big{
      font-family:"Orbitron", monospace;
      font-weight:900;
      letter-spacing:1px;
      font-size:18px;
      color: var(--neonG);
      text-shadow: 0 0 16px rgba(57,255,20,.45);
      white-space:nowrap;
    }

    .btn{
      all:unset;
      cursor:pointer;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background: linear-gradient(135deg, rgba(57,255,20,.22), rgba(0,229,255,.16));
      box-shadow: 0 10px 20px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.12);
      font-family:"Orbitron", monospace;
      font-weight:900;
      letter-spacing:1.2px;
      text-transform:uppercase;
      font-size:12px;
      text-align:center;
      transition: transform .15s ease;
    }
    .btn:active{ transform: translateY(2px) scale(.99); }
    .btn.secondary{
      background: linear-gradient(135deg, rgba(177,0,255,.20), rgba(57,255,20,.10));
    }
    .btn.danger{
      background: linear-gradient(135deg, rgba(255,77,141,.22), rgba(177,0,255,.14));
    }

    /* Overlays */
    .overlay{
      position:absolute; inset:0;
      border-radius: var(--radius);
      background: rgba(2,6,6,.70);
      backdrop-filter: blur(10px);
      display:grid;
      place-items:center;
      z-index:400;
    }
    .card{
      width:min(92%, 460px);
      border-radius:24px;
      border:1px solid var(--stroke);
      background: linear-gradient(145deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      backdrop-filter: blur(20px);
      box-shadow: 0 18px 54px rgba(0,0,0,.55), 0 0 70px rgba(0,229,255,.10);
      padding:22px 18px 16px;
      position:relative;
      overflow:hidden;
    }
    .title{
      font-family:"Orbitron", monospace;
      font-weight:900;
      letter-spacing:2px;
      text-transform:uppercase;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      margin-bottom:6px;
    }
    .subtitle{
      text-align:center;
      margin:0 0 16px;
      opacity:.9;
      line-height:1.5;
      font-size:13px;
    }
    .subtitle b{ color:var(--neonG); text-shadow:0 0 14px rgba(57,255,20,.45); }
    .rowBtns{ display:flex; gap:10px; flex-wrap:wrap; }
    .hint{
      margin-top:12px;
      font-size:11px;
      opacity:.78;
      text-align:center;
      line-height:1.45;
    }
    .hide{ display:none !important; }
  </style>
</head>
<body>
<div id="wrap">
  <div id="stage">
    <canvas id="c" aria-label="FOMO SAPO Swamp Tongue game"></canvas>

    <!-- HUD -->
    <div class="hud">
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">Best: <b id="best">0</b></div>

      <div class="pill" id="sapPill">Swamp Sap: <b id="sap">3</b></div>
      <div class="pill warn" id="wavePill">Hunt Wave: <b id="waveTime">‚Äî</b>s</div>
    </div>

    <!-- Side handles -->
    <div class="tab-handle" id="handleLeft"><span>PROGRESS</span></div>
    <div class="tab-handle" id="handleRight"><span>VAULT</span></div>

    <!-- Panels -->
    <div class="panel" id="panelLeft">
      <h3>Progress</h3>
      <div class="row">
        <div class="muted">Best score</div>
        <div class="big" id="best2">0</div>
      </div>
      <div class="row">
        <div class="muted">Total fireflies eaten</div>
        <div class="big" id="totalEaten">0</div>
      </div>
      <div class="muted">
        Later upgrades: tongue speed, spawn rate, bonus multipliers, sap capacity.
      </div>
    </div>

    <div class="panel" id="panelRight">
      <h3>Vault (Passive Rewards)</h3>
      <div class="row">
        <div class="muted">Available to claim</div>
        <div class="big" id="vaultAvailable">0</div>
      </div>
      <div class="row">
        <div class="muted">Cap</div>
        <div class="big" id="vaultCap">24h</div>
      </div>
      <div class="row">
        <div class="muted">Progress</div>
        <div class="big" id="vaultProgress">0%</div>
      </div>

      <div class="rowBtns">
        <button class="btn" id="claimBtn">Claim Rewards</button>
        <button class="btn secondary" id="closeVaultBtn">Close</button>
      </div>

      <div class="hint">Passive rewards are separate from Hunt Waves.</div>
    </div>

    <!-- Start overlay -->
    <div class="overlay" id="startOverlay">
      <div class="card">
        <div class="title">üê∏ FOMO SAPO</div>
        <p class="subtitle">
          Tap a <b>firefly</b> ‚Äî the frog tongue hunts it down.<br/>
          Each catch is <b>+5 points</b>.<br/>
          A <b>Hunt Wave</b> lasts <b>14 seconds</b> and costs <b>1 Swamp Sap</b>.
        </p>
        <div class="rowBtns">
          <button class="btn" id="playBtn">Play</button>
          <button class="btn secondary" id="soundBtn">Sound: ON</button>
        </div>
        <div class="hint">Stop chasing. Start hopping.</div>
      </div>
    </div>

    <!-- Wave end / Out of Sap overlay -->
    <div class="overlay hide" id="waveOverlay">
      <div class="card">
        <div class="title">üåø Swamp Sap Check</div>
        <p class="subtitle" id="waveMsg">
          Your Hunt Wave ended. Start another wave to keep harvesting.
        </p>
        <div class="rowBtns">
          <button class="btn" id="nextWaveBtn">Start Next Wave (1 Sap)</button>
          <button class="btn secondary" id="buySapBtn">Buy Swamp Sap</button>
          <button class="btn danger" id="closeWaveBtn">Close</button>
        </div>
        <div class="hint">
          Payments require Telegram Invoice + backend. For now, "Buy" is a test mock.
        </div>
      </div>
    </div>

    <!-- Game over overlay (optional future mode) -->
    <div class="overlay hide" id="overOverlay">
      <div class="card">
        <div class="title">ü¶ü Hunt Over</div>
        <p class="subtitle">
          Score: <b id="finalScore">0</b> ‚Ä¢ Best: <b id="finalBest">0</b>
        </p>
        <div class="rowBtns">
          <button class="btn" id="retryBtn">Retry</button>
          <button class="btn secondary" id="shareBtn">Share</button>
        </div>
        <div class="hint">Share copies a message to paste in Telegram.</div>
      </div>
    </div>

  </div>
</div>

<script>
(() => {
  /* =========================================================================
     CONFIG
     ========================================================================= */
  const CONFIG = {
    scorePerCatch: 5,

    sap: {
      displayName: "Swamp Sap",
      startSap: 3,
      waveSeconds: 14,
      maxSap: 99,
      dailyFreeSap: 7,
    },

    firefly: {
      radius: 14,
      maxOnScreen: 5,
      spawnEverySec: 0.55,
      speedMin: 16,
      speedMax: 46,
      drift: 18,
    },

    frog: {
      size: 56,
      tongueMaxLenFactor: 0.68,
      tongueOutSpeed: 1400,
      tongueReturnSpeed: 1600,
    },

    vault: {
      ratePerHour: 25,
      maxHours: 24,
    },

    particles: { sparkleCount: 18 },
  };

  /* =========================================================================
     TELEGRAM INIT
     ========================================================================= */
  const TG = (() => {
    try {
      const tg = window.Telegram?.WebApp;
      if (!tg) return null;
      tg.ready();
      tg.expand();
      if (tg.setHeaderColor) tg.setHeaderColor("#07110d");
      if (tg.setBackgroundColor) tg.setBackgroundColor("#07110d");
      return tg;
    } catch (e) { return null; }
  })();

  function haptic(type = "light") {
    try { TG?.HapticFeedback?.impactOccurred(type); } catch(e){}
  }

  /* =========================================================================
     DOM
     ========================================================================= */
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const best2El = document.getElementById("best2");
  const totalEatenEl = document.getElementById("totalEaten");

  const sapEl = document.getElementById("sap");
  const waveTimeEl = document.getElementById("waveTime");
  const sapPill = document.getElementById("sapPill");
  const wavePill = document.getElementById("wavePill");

  const startOverlay = document.getElementById("startOverlay");
  const waveOverlay = document.getElementById("waveOverlay");
  const waveMsg = document.getElementById("waveMsg");

  const playBtn  = document.getElementById("playBtn");
  const soundBtn = document.getElementById("soundBtn");

  const nextWaveBtn = document.getElementById("nextWaveBtn");
  const buySapBtn = document.getElementById("buySapBtn");
  const closeWaveBtn = document.getElementById("closeWaveBtn");

  const handleLeft = document.getElementById("handleLeft");
  const handleRight = document.getElementById("handleRight");
  const panelLeft = document.getElementById("panelLeft");
  const panelRight = document.getElementById("panelRight");

  const claimBtn = document.getElementById("claimBtn");
  const closeVaultBtn = document.getElementById("closeVaultBtn");

  const vaultAvailableEl = document.getElementById("vaultAvailable");
  const vaultProgressEl  = document.getElementById("vaultProgress");
  const vaultCapEl       = document.getElementById("vaultCap");

  /* =========================================================================
     ASSETS (Telegram Mini App friendly)
     ========================================================================= */
  const ASSETS = {
    bg: "bg.png",
    frog: "frog.png",
  };

  const IMG = {
    bg: new Image(),
    frog: new Image(),
  };
  IMG.bg.decoding = "async";
  IMG.frog.decoding = "async";

  let assetsReady = false;

  function loadAssets() {
    return new Promise((resolve) => {
      let left = 2;
      const done = () => { 
        left--; 
        if (left <= 0) { assetsReady = true; resolve(); } 
      };

      IMG.bg.onload = done; 
      IMG.bg.onerror = () => { console.error("Erro BG"); done(); };
      IMG.frog.onload = done; 
      IMG.frog.onerror = () => { console.error("Erro Frog"); done(); };

      // Vers√£o sem erro de sintaxe para celular
      IMG.bg.src = "bg.png?v=" + Date.now();
      IMG.frog.src = "frog.png?v=" + Date.now();
    });
  }

  /* =========================================================================
     RESPONSIVE CANVAS
     ========================================================================= */
  function resize() {
    const stage = document.getElementById("stage");
    const rect = stage.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  const W = () => canvas.getBoundingClientRect().width;
  const H = () => canvas.getBoundingClientRect().height;

  /* =========================================================================
     STORAGE KEYS
     ========================================================================= */
  const KEYS = {
    best: "swampTongue_best_v3",
    totalEaten: "swampTongue_totalEaten_v3",
    lastClaimTs: "swampTongue_lastClaimTs_v3",
    banked: "swampTongue_banked_v3",
    sap: "swampTongue_sap_v3",
    lastFreeDate: "swampTongue_lastFreeDate_v3",
  };

  /* =========================================================================
     AUDIO
     ========================================================================= */
  let soundOn = true;
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx = null;
  function beep(freq=440, dur=0.06, type="sine", gain=0.05) {
    if (!soundOn) return;
    try {
      if (!actx) actx = new AudioCtx();
      const o = actx.createOscillator();
      const g = actx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(actx.destination);
      o.start();
      o.stop(actx.currentTime + dur);
    } catch(e){}
  }
  const sfxCatch = () => { beep(900,0.05,"square",0.05); beep(1350,0.04,"square",0.035); };
  const sfxClick = () => beep(520,0.04,"sine",0.04);

  soundBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault(); e.stopPropagation();
    soundOn = !soundOn;
    soundBtn.textContent = soundOn ? "Sound: ON" : "Sound: OFF";
    if (soundOn) beep(660,0.04,"sine",0.04);
    haptic("light");
  }, { passive:false });

  /* =========================================================================
     HELPERS
     ========================================================================= */
  const rand = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
  const dist2 = (ax,ay,bx,by) => (ax-bx)*(ax-bx) + (ay-by)*(ay-by);

  function easeOutCubic(x){ return 1 - Math.pow(1 - x, 3); }
  function damp(current, target, lambda, dt){
    return current + (target - current) * (1 - Math.exp(-lambda * dt));
  }

  /* =========================================================================
     PLAYER STATS
     ========================================================================= */
  let score = 0;
  let best = Number(localStorage.getItem(KEYS.best) || 0);
  let totalEaten = Number(localStorage.getItem(KEYS.totalEaten) || 0);

  bestEl.textContent = String(best);
  best2El.textContent = String(best);
  totalEatenEl.textContent = String(totalEaten);
  scoreEl.textContent = "0";

  /* =========================================================================
     SWAMP SAP + DAILY FREE CREDITS
     ========================================================================= */
  let sap = Number(localStorage.getItem(KEYS.sap));
  if (!Number.isFinite(sap) || sap < 0) sap = CONFIG.sap.startSap;

  // ===== DAILY FREE CREDITS (7 per day) =====
  const lastFreeDate = localStorage.getItem(KEYS.lastFreeDate);
  const today = new Date().toDateString();

  if (lastFreeDate !== today) {
    sap = Math.min(sap + CONFIG.sap.dailyFreeSap, CONFIG.sap.maxSap);
    localStorage.setItem(KEYS.lastFreeDate, today);
    localStorage.setItem(KEYS.sap, String(sap));

    setTimeout(() => {
      try {
        TG?.showPopup?.({
          title: "üåø Daily Swamp Sap",
          message: `You received +$${CONFIG.sap.dailyFreeSap} free Swamp Sap today!`,
          buttons: [{type:"ok"}]
        });
      } catch(e){}
    }, 800);
  }

  let waveActive = false;
  let waveTimeLeft = 0;

  function saveSap() { localStorage.setItem(KEYS.sap, String(sap)); }

  function updateSapUI() {
    sapEl.textContent = String(sap);
    if (sap <= 0) sapPill.classList.add("danger");
    else sapPill.classList.remove("danger");
  }

  function updateWaveUI() {
    if (!waveActive) {
      waveTimeEl.textContent = "‚Äî";
      wavePill.classList.remove("danger");
      wavePill.classList.add("warn");
      return;
    }
    waveTimeEl.textContent = String(Math.max(0, Math.ceil(waveTimeLeft)));
    if (waveTimeLeft <= 3) {
      wavePill.classList.add("danger");
    } else {
      wavePill.classList.remove("danger");
    }
  }

  function openWaveOverlay(message) {
    waveMsg.textContent = message;
    waveOverlay.classList.remove("hide");
  }
  function closeWaveOverlay() {
    waveOverlay.classList.add("hide");
  }

  function stopWave() {
    waveActive = false;
    waveTimeLeft = 0;
    updateWaveUI();
  }

  function startWave() {
    if (sap <= 0) {
      stopWave();
      openWaveOverlay("You're out of Swamp Sap. Buy more to keep harvesting.");
      return false;
    }
    sap = Math.max(0, sap - 1);
    saveSap();
    updateSapUI();

    waveActive = true;
    waveTimeLeft = CONFIG.sap.waveSeconds;
    updateWaveUI();

    closeWaveOverlay();
    haptic("light");
    sfxClick();
    return true;
  }

  /* =========================================================================
     PURCHASE HOOKS
     ========================================================================= */
  function purchaseEnergyMock(amount = 5) {
    sap = clamp(sap + amount, 0, CONFIG.sap.maxSap);
    saveSap();
    updateSapUI();
    openWaveOverlay(`Added +$${amount} Swamp Sap (TEST). Start a Hunt Wave!`);
    haptic("medium");
    sfxClick();
  }

  function purchaseEnergyTelegramStub() {
    try {
      TG?.showPopup?.({
        title: "Payments (stub)",
        message: "To enable real purchases, connect a backend to create Telegram invoices. For now, we will add TEST Sap.",
        buttons: [{type:"ok"}]
      });
    } catch(e){}
    purchaseEnergyMock(5);
  }

  buySapBtn.addEventListener("pointerdown", (e)=>{
    e.preventDefault(); e.stopPropagation();
    purchaseEnergyTelegramStub();
  }, { passive:false });

  nextWaveBtn.addEventListener("pointerdown", (e)=>{
    e.preventDefault(); e.stopPropagation();
    startWave();
  }, { passive:false });

  closeWaveBtn.addEventListener("pointerdown", (e)=>{
    e.preventDefault(); e.stopPropagation();
    closeWaveOverlay();
  }, { passive:false });

  /* =========================================================================
     VAULT
     ========================================================================= */
  function nowMs() { return Date.now(); }

  function getLastClaimTs() {
    const v = Number(localStorage.getItem(KEYS.lastClaimTs) || 0);
    if (!v) {
      const ts = nowMs();
      localStorage.setItem(KEYS.lastClaimTs, String(ts));
      return ts;
    }
    return v;
  }

  function computeVaultAvailable() {
    const last = getLastClaimTs();
    const elapsedMs = Math.max(0, nowMs() - last);
    const elapsedHours = elapsedMs / (1000*60*60);

    const cappedHours = Math.min(elapsedHours, CONFIG.vault.maxHours);
    const available = Math.floor(cappedHours * CONFIG.vault.ratePerHour);
    const progress = Math.min(1, cappedHours / CONFIG.vault.maxHours);

    return { available, progress, cappedHours };
  }

  function refreshVaultUI() {
    const { available, progress } = computeVaultAvailable();
    vaultAvailableEl.textContent = String(available);
    vaultProgressEl.textContent = Math.round(progress * 100) + "%";
    vaultCapEl.textContent = CONFIG.vault.maxHours + "h";

    try {
      if (TG?.MainButton) {
        if (available > 0) {
          TG.MainButton.setText("CLAIM REWARDS");
          TG.MainButton.show();
          TG.MainButton.onClick(claimVault);
        } else {
          TG.MainButton.hide();
        }
      }
    } catch(e){}
  }

  function claimVault() {
    const { available } = computeVaultAvailable();
    if (available <= 0) return;

    const banked = Number(localStorage.getItem(KEYS.banked) || 0);
    localStorage.setItem(KEYS.banked, String(banked + available));
    localStorage.setItem(KEYS.lastClaimTs, String(nowMs()));
    refreshVaultUI();

    sfxClick();
    haptic("medium");
  }

  claimBtn.addEventListener("pointerdown", (e)=> {
    e.preventDefault(); e.stopPropagation();
    claimVault();
  }, { passive:false });

  closeVaultBtn.addEventListener("pointerdown", (e)=> {
    e.preventDefault(); e.stopPropagation();
    panelRight.style.display = "none";
    haptic("light");
  }, { passive:false });

  /* =========================================================================
     UI PANELS
     ========================================================================= */
  function togglePanel(panel) {
    const isOpen = panel.style.display === "block";
    panelLeft.style.display = "none";
    panelRight.style.display = "none";
    panel.style.display = isOpen ? "none" : "block";
    haptic("light");
  }

  handleLeft.addEventListener("pointerdown", (e)=>{
    e.preventDefault(); e.stopPropagation();
    togglePanel(panelLeft);
  }, { passive:false });

  handleRight.addEventListener("pointerdown", (e)=>{
    e.preventDefault(); e.stopPropagation();
    refreshVaultUI();
    togglePanel(panelRight);
  }, { passive:false });

  /* =========================================================================
     GAME OBJECTS
     ========================================================================= */
  let state = "start";
  let tPrev = 0;

  const frog = {
    x: 0,
    y: 0,
    size: CONFIG.frog.size,
    tongue: { active:false, phase:"out", len:0, target:null, hitFireflyId:null },
    anim: {
      bob: 0,
      squash: 0,
      recoil: 0,
    }
  };

  let fireflies = [];
  let spawnTimer = 0;
  let nextId = 1;
  let particles = [];

  /* =========================================================================
     START GAME
     ========================================================================= */
  async function startGame() {
    if (!assetsReady) await loadAssets();

    state = "play";
    startOverlay.classList.add("hide");

    score = 0;
    scoreEl.textContent = "0";

    frog.x = W()*0.5;
    frog.y = H()*0.85;

    frog.tongue.active = false;
    frog.tongue.len = 0;
    frog.tongue.target = null;
    frog.tongue.hitFireflyId = null;

    frog.anim.bob = 0;
    frog.anim.squash = 0;
    frog.anim.recoil = 0;

    fireflies = [];
    particles = [];
    spawnTimer = 0;

    refreshVaultUI();
    updateSapUI();
    updateWaveUI();

    if (!startWave()) {
      // no sap
    }
  }

  playBtn.addEventListener("pointerdown", (e)=>{
    e.preventDefault(); e.stopPropagation();
    startGame();
    sfxClick();
    haptic("light");
  }, { passive:false });

  /* =========================================================================
     SPAWN + UPDATE FIREFLIES (safe area)
     ========================================================================= */
  function spawnFirefly() {
    if (fireflies.length >= CONFIG.firefly.maxOnScreen) return;

    const w = W(), h = H();

    const marginTop = 90;
    const marginBottom = h * 0.25;
    const marginSide = 60;

    let x = rand(marginSide, w - marginSide);
    let y = rand(marginTop, h - marginBottom);

    const safeR = 100;
    if (dist2(x, y, frog.x, frog.y) < safeR * safeR) {
      y -= 100;
    }

    const speed = rand(CONFIG.firefly.speedMin, CONFIG.firefly.speedMax);
    const ang = rand(0, Math.PI*2);

    fireflies.push({
      id: nextId++,
      x, y,
      vx: Math.cos(ang)*speed,
      vy: Math.sin(ang)*speed,
      r: CONFIG.firefly.radius,
      phase: rand(0, Math.PI*2),
      alive: true,
    });
  }

  function updateFireflies(dt, t) {
    const w = W(), h = H();
    for (const f of fireflies) {
      const drift = CONFIG.firefly.drift;
      f.phase += dt * 1.6;

      f.x += f.vx * dt + Math.sin(f.phase) * drift * dt;
      f.y += f.vy * dt + Math.cos(f.phase * 0.9) * drift * dt;

      if (f.x < 60) { f.x=60; f.vx = Math.abs(f.vx); }
      if (f.x > w - 60) { f.x=w - 60; f.vx = -Math.abs(f.vx); }
      if (f.y < 90) { f.y=90; f.vy = Math.abs(f.vy); }
      if (f.y > h - (h * 0.25)) { f.y = h - (h * 0.25); f.vy = -Math.abs(f.vy); }
    }
  }

  /* =========================================================================
     TONGUE MECHANIC (smooth clean curve)
     ========================================================================= */
  function tongueMaxLen() {
    return Math.min(W(), H()) * CONFIG.frog.tongueMaxLenFactor;
  }

  function fireflyAtPoint(x,y) {
    let best = null, bestD = Infinity;
    for (const f of fireflies) {
      if (!f.alive) continue;
      const d = dist2(x,y,f.x,f.y);
      const r = (f.r + 14);
      if (d <= r*r && d < bestD) { best = f; bestD = d; }
    }
    return best;
  }

  function onTap(x,y) {
    if (state !== "play") return;
    if (!waveActive) {
      openWaveOverlay("No active Hunt Wave. Start a wave to harvest fireflies.");
      return;
    }
    if (panelLeft.style.display === "block" || panelRight.style.display === "block") return;

    const target = fireflyAtPoint(x,y);
    if (!target) { sfxClick(); haptic("light"); return; }

    frog.tongue.active = true;
    frog.tongue.phase = "out";
    frog.tongue.len = 0;
    frog.tongue.target = { x: target.x, y: target.y };
    frog.tongue.hitFireflyId = target.id;

    frog.anim.squash = Math.min(1, frog.anim.squash + 0.9);
    frog.anim.recoil = Math.min(1, frog.anim.recoil + 0.75);

    sfxClick(); haptic("light");
  }

  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    onTap(e.clientX - rect.left, e.clientY - rect.top);
  }, { passive:false });

  function updateTongue(dt) {
    if (!frog.tongue.active) return;

    const tx = frog.tongue.target.x;
    const ty = frog.tongue.target.y;
    const dx = tx - frog.x;
    const dy = ty - frog.y;
    const d = Math.sqrt(dx*dx + dy*dy);

    const targetLen = Math.min(d, tongueMaxLen());

    if (frog.tongue.phase === "out") {
      frog.tongue.len += CONFIG.frog.tongueOutSpeed * dt;
      if (frog.tongue.len >= targetLen) {
        frog.tongue.len = targetLen;

        const hit = fireflies.find(f => f.id === frog.tongue.hitFireflyId && f.alive);
        if (hit) {
          hit.alive = false;
          score += CONFIG.scorePerCatch;
          scoreEl.textContent = String(score);

          totalEaten += 1;
          localStorage.setItem(KEYS.totalEaten, String(totalEaten));
          totalEatenEl.textContent = String(totalEaten);

          sfxCatch();
          haptic("medium");
          spawnSparkles(hit.x, hit.y);

          frog.anim.squash = Math.min(1, frog.anim.squash + 0.6);
          frog.anim.recoil = Math.min(1, frog.anim.recoil + 0.5);

          if (score > best) {
            best = score;
            localStorage.setItem(KEYS.best, String(best));
            bestEl.textContent = String(best);
            best2El.textContent = String(best);
          }
        }
        frog.tongue.phase = "back";
      }
    } else {
      frog.tongue.len -= CONFIG.frog.tongueReturnSpeed * dt;
      if (frog.tongue.len <= 0) {
        frog.tongue.len = 0;
        frog.tongue.active = false;
        frog.tongue.target = null;
        frog.tongue.hitFireflyId = null;
      }
    }
  }

  /* =========================================================================
     PARTICLES
     ========================================================================= */
  function spawnSparkles(x,y) {
    const n = CONFIG.particles.sparkleCount;
    for (let i=0;i<n;i++) {
      const a = (Math.PI*2) * (i/n) + rand(-0.2, 0.2);
      const sp = rand(90, 240);
      particles.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        life: 1,
        r: rand(2, 4.5),
        hue: (i%2===0) ? "rgba(57,255,20,.95)" : "rgba(0,229,255,.90)"
      });
    }
  }
  function updateParticles(dt) {
    for (const p of particles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 420 * dt;
      p.life -= dt * 1.6;
    }
    particles = particles.filter(p => p.life > 0);
  }

  /* =========================================================================
     RENDER (sprites + smooth tongue)
     ========================================================================= */
  function drawImageCover(img, x, y, w, h) {
    if (!img || !img.width) return;
    const iw = img.width, ih = img.height;
    const r = Math.max(w / iw, h / ih);
    const nw = iw * r, nh = ih * r;
    const nx = x + (w - nw) / 2;
    const ny = y + (h - nh) / 2;
    ctx.drawImage(img, nx, ny, nw, nh);
  }

  function drawBackground() {
    drawImageCover(IMG.bg, 0, 0, W(), H());
  }

  function drawFrogSprite(t, dt) {
    frog.anim.bob += dt * 2.2;

    frog.anim.squash = damp(frog.anim.squash, 0, 10, dt);
    frog.anim.recoil = damp(frog.anim.recoil, 0, 12, dt);

    const img = IMG.frog;
    const x = frog.x, y = frog.y;

    const base = frog.size * 1.55;
    const bobY = Math.sin(frog.anim.bob) * 3;

    const sx = 1 + frog.anim.squash * 0.10;
    const sy = 1 - frog.anim.squash * 0.12;

    const recoilY = frog.anim.recoil * 6;

    ctx.save();
    ctx.translate(x, y + bobY + recoilY);
    ctx.scale(sx, sy);

    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(0,0,0,.7)";
    ctx.beginPath();
    ctx.ellipse(0, base*0.45, base*0.55, base*0.16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    if (img && img.width) {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(img, -base/2, -base*0.82, base, base);
    } else {
      ctx.fillStyle = "#39FF14";
      ctx.fillRect(-base/2, -base/2, base, base);
    }

    ctx.restore();
  }

  function drawTongue() {
    if (!frog.tongue.active || !frog.tongue.target) return;

    const tx = frog.tongue.target.x;
    const ty = frog.tongue.target.y;
    const dx = tx - frog.x;
    const dy = ty - frog.y;
    const d = Math.sqrt(dx*dx + dy*dy) || 1;

    const targetLen = Math.min(d, tongueMaxLen());
    const ratio = clamp(frog.tongue.len / targetLen, 0, 1);

    // Smooth easing (clean curve, no overshoot)
    const easedRatio = easeOutCubic(ratio);

    const tipX = frog.x + dx * easedRatio;
    const tipY = frog.y + dy * easedRatio;

    const cx = frog.x + dx * 0.45 + (-dy) * 0.08;
    const cy = frog.y + dy * 0.45 + ( dx) * 0.08;

    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.shadowColor = "rgba(255,80,160,.65)";
    ctx.shadowBlur = 18;
    ctx.strokeStyle = "rgba(255,120,190,.95)";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(frog.x, frog.y - frog.size*0.55);
    ctx.quadraticCurveTo(cx, cy, tipX, tipY);
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = "rgba(255,210,235,.95)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(frog.x, frog.y - frog.size*0.55);
    ctx.quadraticCurveTo(cx, cy, tipX, tipY);
    ctx.stroke();

    ctx.restore();
  }

  function drawFirefly(f, t) {
    const glow = 0.5 + 0.5*Math.sin(t*3.2 + f.phase);
    ctx.save();
    ctx.globalAlpha = 0.25 + 0.65*glow;
    ctx.shadowColor = "rgba(255,215,0,.95)";
    ctx.shadowBlur = 28;

    ctx.fillStyle = "rgba(255,215,0,.85)";
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.r*(1.35+0.25*glow), 0, Math.PI*2);
    ctx.fill();

    ctx.shadowBlur = 12;
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(255,255,210,.95)";
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.r*(0.55+0.15*glow), 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawParticles() {
    for (const p of particles) {
      ctx.save();
      ctx.globalAlpha = p.life;
      ctx.shadowColor = p.hue;
      ctx.shadowBlur = 12;
      ctx.fillStyle = p.hue;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  /* =========================================================================
     MAIN LOOP
     ========================================================================= */
  function update(dt, t) {
    refreshVaultUI();

    if (waveActive) {
      waveTimeLeft -= dt;
      if (waveTimeLeft <= 0) {
        stopWave();
        fireflies = [];
        openWaveOverlay("Your Hunt Wave ended. Start another wave to keep harvesting.");
        haptic("light");
      }
      updateWaveUI();
    }

    if (state !== "play") return;

    if (waveActive) {
      spawnTimer += dt;
      if (spawnTimer >= CONFIG.firefly.spawnEverySec) {
        spawnTimer = 0;
        spawnFirefly();
      }
    } else {
      spawnTimer = 0;
    }

    updateFireflies(dt, t);
    updateTongue(dt);
    updateParticles(dt);

    fireflies = fireflies.filter(f => f.alive);
  }

  function render(t, dt) {
    ctx.clearRect(0, 0, W(), H());
    drawBackground();
    for (const f of fireflies) drawFirefly(f, t);
    drawTongue();
    drawFrogSprite(t, dt);
    drawParticles();
  }

  function loop(ts) {
    const t = ts / 1000;
    const dt = Math.min(0.033, (ts - tPrev) / 1000 || 0);
    tPrev = ts;
    update(dt, t);
    render(t, dt);
    requestAnimationFrame(loop);
  }

  /* =========================================================================
     INIT
     ========================================================================= */
  startOverlay.addEventListener("pointerdown", (e)=> {
    if (e.target.tagName === "BUTTON") return;
    e.stopPropagation();
  }, { passive:false });

  waveOverlay.addEventListener("pointerdown", (e)=> {
    if (e.target.tagName === "BUTTON") return;
    e.stopPropagation();
  }, { passive:false });

  frog.x = W()*0.5;
  frog.y = H()*0.85;

  updateSapUI();
  updateWaveUI();
  refreshVaultUI();

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
